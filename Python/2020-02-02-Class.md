# Regular Class

### create a class

method 1: normally

~~~python
class Foo:
    pass
~~~

method 2: use type

~~~python
>>> Hello = type('Hello', (object, ), dict(hello=lambda self: 1+1))
~~~

## how to generate a instance?

The order: `create` -> `initialize`.

If `__new__` is invoked during the object construction, and then `__init__` will be invoked immediately along with `self` passed. If `__new__()` does not return an instance of cls, then the new instanceâ€™s `__init__()` method will not be invoked.

**For instance:**

~~~python
class Foo: 
    def __new__(cls): 
        res = super(Foo, cls).__new__(cls) 
        print(cls, res) 
        return res 
    def __init__(self): 
        print(self) 

>>> c = Foo()
<class '__main__.Foo'> <__main__.Foo object at 0x7fc3b42297f0>
<__main__.Foo object at 0x7fc3b42297f0>
~~~

And, to implement singleton:

~~~python
class Singleton:
    _instance = None
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)
        return cls._instance
~~~

**create a instance: `__new__`**

- object.\_\_new\_\_(cls[, ...])

cls.\_\_new\_\_() is a static method. The return value of \_\_new\_\_() should be the new object instance (usually an instance of cls).

**initialize a instance: `__init__`**

no non-`None` value may be returned by `__init__`.

# Metaclass

What Metaclass is, in a nutshell, class of class.

~~~python
>>> class Metaclass(type):
...     pass
... 
>>> type(Metaclass)
<class 'type'>

>>> class MyClass(metaclass=Metaclass):
...     pass
... 
>>> type(MyClass)
<class '__main__.Metaclass'>
~~~

**For instance**

~~~python
class Metaclass(type): 
    def __new__(cls, name, bases, attrs): 
        print('Metaclass__new__') 
        res = super(Metaclass, cls).__new__(cls, name, bases, attrs) 
        print('Metaclass__new__', res, cls, name, bases, attrs) 
        return res 
    def __init__(cls, name, bases, attrs): 
        print('Metaclass__init__', cls, name, bases, attrs) 
        super(Metaclass, cls).__init__(name, bases, attrs) 
        print('Metaclass__init__') 
    def __call__(cls, *args, **kwargs): 
        print('Metaclass__call__') 
        res = super(Metaclass, cls).__call__(*args, **kwargs) 
        print('Metaclass__call__', res, cls, args, kwargs) 
        return res 
                                                                       

class Myclass(metaclass=Metaclass): 
    def __new__(cls, *args, **kw): 
        print('myclass__new__') 
        res = super(Myclass, cls).__new__(cls)  # object has no parameters 
        print('myclass__new__', res, cls, args, kw) 
        return res 
    def __init__(self, name): 
        print('myclass__init__', self) 
        self.name = name 
    def get_name(self): 
        return self.name 

# output
Metaclass__new__
Metaclass__new__ <class '__main__.Myclass'> <class '__main__.Metaclass'> Myclass () {'__module__': '__main__', '__qualname__': 'Myclass', '__new__': <function Myclass.__new__ at 0x7f34803db488>, '__init__': <function Myclass.__init__ at 0x7f34803dbea0>, 'get_name': <function Myclass.get_name at 0x7f34803db0d0>, '__classcell__': <cell at 0x7f34812e9b88: Metaclass object at 0x28add68>}
Metaclass__init__ <class '__main__.Myclass'> Myclass () {'__module__': '__main__', '__qualname__': 'Myclass', '__new__': <function Myclass.__new__ at 0x7f34803db488>, '__init__': <function Myclass.__init__ at 0x7f34803dbea0>, 'get_name': <function Myclass.get_name at 0x7f34803db0d0>, '__classcell__': <cell at 0x7f34812e9b88: Metaclass object at 0x28add68>}
Metaclass__init__

>>> c = Myclass('cool')                                                    
Metaclass__call__
myclass__new__
myclass__new__ <__main__.Myclass object at 0x7f34813672b0> <class '__main__.Myclass'> ('cool',) {}
myclass__init__ <__main__.Myclass object at 0x7f34813672b0>
Metaclass__call__ <__main__.Myclass object at 0x7f34813672b0> <class '__main__.Myclass'> ('cool',) {}

>>> c.name                                                                 
'cool'

>>> c.get_name()                                                           
'cool'
~~~

As we can see, the order is roughly: 

- when create a class which is the instance of metaclass 'Metaclass'

**`Metaclass's __new__` -> `Metaclass's __init__`**

- when create a instance which is the instance of class 'Myclass'

**`(begin)Metaclass's __call__` -> (`Myclass's __new__` -> `Myclass's __init__`) -> `Metaclass's __call__`(over)**

<u>There are some weird things, which I am not still clear about</u>

- In `Myclass`, the `__new__` which I redefine get all parameters (include 'cool' besides cls), and the `object` just take a parameter which is cls. (And more thing: the `Metaclass __call__` take the same parameters as `Myclass __new__`). Their relationship is complicated!

- How does the super() work exactly?

- ...

A small use of its functionality:

add a method for its 'instance'

~~~python
class Metaclass(type): 
    def __new__(cls, name, bases, attrs): 
        attrs['response'] = lambda self: "I am response" 
        return type.__new__(cls, name, bases, attrs)

>>> class myclass(metaclass=Metaclass): pass
>>> c = myclass()
>>> c.response()                                                           
'I am response'
~~~


