# Regular Class

### create a class

method 1: normally

~~~python
class Foo:
    pass
~~~

method 2: use type

~~~python
>>> MyClass = type('MyClass', (MySuperClass, MyMixin), dict(x=42, foo=lambda self: 'have fun'))

# the code above is functionally equivalent to:
class MyClass(MySuperClass, MyMixin):
    x = 42
    
    def foo(self):
        return 'have fun'
~~~

## how to generate a instance?

The order: `construct` -> `initialize`.

If `__new__` is invoked during the object construction, and then `__init__` will be invoked immediately along with `self` passed. If `__new__()` does not return an instance of cls, then the new instance’s `__init__()` method will not be invoked.The `__new__` method can also return an instance of a different class, and when that happens, the interpreter does not call `__init__` . Actually, `__init__` is forbidden from returning anything, it's really an 'intializer'.

**For instance:**

~~~python
class Foo: 
    def __new__(cls): 
        # or object.__new__(cls)
        # res = super(Foo, cls).__new__(cls) 
        res = super().__new__(cls) 
        print(cls, res) 
        return res 
    def __init__(self): 
        print(self) 

>>> c = Foo()
<class '__main__.Foo'> <__main__.Foo object at 0x7fc3b42297f0>
<__main__.Foo object at 0x7fc3b42297f0>
~~~

And, to implement singleton:

~~~python
class Singleton:
    _instance = None
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)
        return cls._instance
~~~

**create a instance: `__new__`**

- object.\_\_new\_\_(cls[, ...])

cls.\_\_new\_\_() is a static method. The return value of \_\_new\_\_() should be the new object instance (usually an instance of cls).

**initialize a instance: `__init__`**

no non-`None` value may be returned by `__init__`.

## Special Method

- *\_\_dict\_\_*

The `__dict__` of an object is where its attributes are kept

First of all:

~~~python
class Foo:
    def __init__(self, name):
        self.name = name

>>> Foo.__dict__
mappingproxy({'__module__': '__main__', '__init__': <function Foo.__init__ at 0x7f79e9982c80>, '__dict__': <attribute '__dict__' of 'Foo' objects>, '__weakref__': <attribute '__weakref__' of 'Foo' objects>, '__doc__': None})
>>> f = Foo('guido')
>>> f.name
'guido'
>>> f.__dict__
{'name': 'guido'}
>>> f.__dict__['wow'] = 'wow'
>>> f.wow
'wow'
>>> f.__dict__
{'name': 'guido', 'wow': 'wow'}
~~~

So, instance's `__dict__` is just for their attrs, not including class's attrs. And if the same attrs occur in class namespace, instance is prior.

Attribute assignments and deletions update the instance’s dictionary, never a class’s dictionary.

- *\_\_init\_\_*

> To initialize instance

There is a triky for initialize many instance's attributes quickly:

~~~python
class Record:
    def __init__(self, **kwargs):                                               
        self.__dict__.update(kwargs)
~~~


### Customizing attribute access

> Attribute access using either dot notation or the built-in functions `gettattr` , `hasattr` and `setattr` trigger the appropriate special methods listed here. Reading and writing attributes directly in the instance `__dict__` does not trigger these special methods — and that’s the usual way to bypass them if needed.

- *\_\getattr\_\_(self, name)*

- *\_\setattr\_\_(self, name)*

- *\_\_getattribute\_\_(self, name)*

> Called unconditionally to implement attribute accesses for instances of the class.

A simple instance:

~~~python
class C:
    def __init__(self, name):
        self.name = name
    def __getattr__(self, key):
        return self.name
    def __getattribute__(self, val):
        print('through getattribute')
        return object.__getattribute__(self, val)

>>> c = C('guido')
>>> print(c.name)
through getattribute
guido
~~~

*For more info*

[3.3.2. Customizing attribute access](https://docs.python.org/3/reference/datamodel.html#customizing-attribute-access)

[Python 3 \_\_getattribute\_\_ vs dot access behaviour ](https://stackoverflow.com/questions/39043912/python-3-getattribute-vs-dot-access-behaviour)

### Descriptor

The implementation of ...

> descr.__get__(self, obj, type=None) -> value

- If instance of class invocate descriptor by dot notation, so, the obj is the instance, and the type parameter is type(instance).

- If class invocate descriptor, so the obj is the None, and the type is class.

> descr.__set__(self, obj, value) -> None

> descr.__delete__(self, obj) -> None

- data descriptor: object defines `__set__` or `__delete__`

- non-data descriptor: object defines `__get__`

> precedence: `data descriptor` > `instance's __dict__` > `non-data descriptor`

simple instance:
    
~~~python
class Desc:                                                                     
    def __get__(self, inst, class_):
        print(inst, class_)

    def __set__(self, inst, value):
        print(inst, value)

class C:
    d = Desc()
>>> c = C()
>>> c
<__main__.C object at 0x7f38b4467080>
>>> c.d
<__main__.C object at 0x7f38b4467080> <class '__main__.C'>
>>> C.d
None <class '__main__.C'>
>>> c.d = 1
<__main__.C object at 0x7f38b4467080> 1
>>> C.d = 1
>>> C.d
1
>>> c.d
1
~~~


**Property**

> building a `data descriptor` that triggers function calls upon access to an attribute

- property(fget=None, fset=None, fdel=None, doc=None) -> property attribute

here some code:

~~~python

# Prevent assigning a negative value for price

class LineItem:                                                             
    def __init__(self, description, weight, price):
        self.description = description
        self.weight = weight
        self.price = price

    def subtotal(self):
        return self.weight * self.price

    @property
    def weight(self):
        return self.__weight

    @weight.setter
    def weight(self, value):
        if value > 0:
            self.__weight = value
        else:
            raise ValueError('value must be > 0')

### another way

class LineItem:
    def __init__(self, description, weight, price):
        self.description = description
        self.weight = weight
        self.price = price

    def subtotal(self):
        return self.weight * self.price

    def get_weight(self):
        return self.__weight

    def set_weight(self, value):
        if value > 0:
            self.__weight = value                                           
        else:
            raise ValueError('value must be > 0')

    weight = property(get_weight, set_weight, doc='weight in kilograms')


### function could be also

# Writing and reading directly from instance __dict__

def quantity(storage_name):
    def qty_getter(instance):
        return instance.__dict__[storage_name]

    def qty_setter(instance, value):
        if value > 0:
            # there use `setattr` will lead to infinite recursion
            instance.__dict__[storage_name] = value
        else:
            raise ValueError('value must be > 0')

    return property(qty_getter, qty_setter)

class LineItem:                                                                 
    weight = quantity('weight')
    prince = quantity('price')

    def __init__(self, description, weight, price):
        self.description = description
        self.weight = weight
        self.price = price

    def subtotal(self):
        return self.weight * self.price
~~~

*for more info*

[Descriptor HowTo Guide](https://docs.python.org/3/howto/descriptor.html)

---

# Metaclass

What Metaclass is, in a nutshell, class of class.

~~~python
>>> class Metaclass(type):
...     pass
... 
>>> type(Metaclass)
<class 'type'>

>>> class MyClass(metaclass=Metaclass):
...     pass
... 
>>> type(MyClass)
<class '__main__.Metaclass'>
~~~

**For instance**

~~~python
class Metaclass(type): 
    def __new__(cls, name, bases, attrs): 
        print('Metaclass__new__') 
        res = super(Metaclass, cls).__new__(cls, name, bases, attrs) 
        print('Metaclass__new__', res, cls, name, bases, attrs) 
        return res 
    def __init__(cls, name, bases, attrs): 
        print('Metaclass__init__', cls, name, bases, attrs) 
        super(Metaclass, cls).__init__(name, bases, attrs) 
        print('Metaclass__init__') 
    def __call__(cls, *args, **kwargs): 
        print('Metaclass__call__') 
        res = super(Metaclass, cls).__call__(*args, **kwargs) 
        print('Metaclass__call__', res, cls, args, kwargs) 
        return res 
                                                                       

class Myclass(metaclass=Metaclass): 
    def __new__(cls, *args, **kw): 
        print('myclass__new__') 
        res = super(Myclass, cls).__new__(cls)  # object has no parameters 
        print('myclass__new__', res, cls, args, kw) 
        return res 
    def __init__(self, name): 
        print('myclass__init__', self) 
        self.name = name 
    def get_name(self): 
        return self.name 

# output
Metaclass__new__
Metaclass__new__ <class '__main__.Myclass'> <class '__main__.Metaclass'> Myclass () {'__module__': '__main__', '__qualname__': 'Myclass', '__new__': <function Myclass.__new__ at 0x7f34803db488>, '__init__': <function Myclass.__init__ at 0x7f34803dbea0>, 'get_name': <function Myclass.get_name at 0x7f34803db0d0>, '__classcell__': <cell at 0x7f34812e9b88: Metaclass object at 0x28add68>}
Metaclass__init__ <class '__main__.Myclass'> Myclass () {'__module__': '__main__', '__qualname__': 'Myclass', '__new__': <function Myclass.__new__ at 0x7f34803db488>, '__init__': <function Myclass.__init__ at 0x7f34803dbea0>, 'get_name': <function Myclass.get_name at 0x7f34803db0d0>, '__classcell__': <cell at 0x7f34812e9b88: Metaclass object at 0x28add68>}
Metaclass__init__

>>> c = Myclass('cool')                                                    
Metaclass__call__
myclass__new__
myclass__new__ <__main__.Myclass object at 0x7f34813672b0> <class '__main__.Myclass'> ('cool',) {}
myclass__init__ <__main__.Myclass object at 0x7f34813672b0>
Metaclass__call__ <__main__.Myclass object at 0x7f34813672b0> <class '__main__.Myclass'> ('cool',) {}

>>> c.name                                                                 
'cool'

>>> c.get_name()                                                           
'cool'
~~~

As we can see, the order is roughly: 

- when create a class which is the instance of metaclass 'Metaclass'

**`Metaclass's __new__` -> `Metaclass's __init__`**

- when create a instance which is the instance of class 'Myclass'

**`(begin)Metaclass's __call__` -> (`Myclass's __new__` -> `Myclass's __init__`) -> `Metaclass's __call__`(over)**

<u>There are some weird things, which I am not still clear about</u>

- In `Myclass`, the `__new__` which I redefine get all parameters (include 'cool' besides cls), and the `object` just take a parameter which is cls. (And more thing: the `Metaclass __call__` take the same parameters as `Myclass __new__`). Their relationship is complicated!

- How does the super() work exactly?

- ...

A small use of its functionality:

add a method for its 'instance'

~~~python
class Metaclass(type): 
    def __new__(cls, name, bases, attrs): 
        attrs['response'] = lambda self: "I am response" 
        return type.__new__(cls, name, bases, attrs)

>>> class myclass(metaclass=Metaclass): pass
>>> c = myclass()
>>> c.response()                                                           
'I am response'
~~~

*For more information*

[使用元类](https://www.liaoxuefeng.com/wiki/1016959663602400/1017592449371072)

[Python official doc: Data model](https://docs.python.org/3/reference/datamodel.html#basic-customization)

<<Fluent Python>> -Luciano Ramalho
